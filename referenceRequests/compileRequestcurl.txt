curl ^"https://vyper2.remixproject.org/compile^" ^
  -H ^"Accept: application/json, text/plain, */*^" ^
  -H ^"Accept-Language: en-US,en;q=0.9^" ^
  -H ^"Connection: keep-alive^" ^
  -H ^"Content-Type: application/json^" ^
  -H ^"DNT: 1^" ^
  -H ^"Origin: https://remix.ethereum.org^" ^
  -H ^"Referer: https://remix.ethereum.org/^" ^
  -H ^"Sec-Fetch-Dest: empty^" ^
  -H ^"Sec-Fetch-Mode: cors^" ^
  -H ^"Sec-Fetch-Site: cross-site^" ^
  -H ^"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36^" ^
  -H ^"sec-ch-ua: ^\^"Not A(Brand^\^";v=^\^"8^\^", ^\^"Chromium^\^";v=^\^"132^\^", ^\^"Google Chrome^\^";v=^\^"132^\^"^" ^
  -H ^"sec-ch-ua-mobile: ?0^" ^
  -H ^"sec-ch-ua-platform: ^\^"Windows^\^"^" ^
  --data-raw ^"^{^\^"manifest^\^":^\^"ethpm/3^\^",^\^"sources^\^":^{^\^"examples/tokens/ERC20.vy^\^":^{^\^"content^\^":^\^"^#pragma version ^>0.3.10^\^\n^\^\n^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^\^\n^#^# THIS IS EXAMPLE CODE, NOT MEANT TO BE USED IN PRODUCTION^! CAVEAT EMPTOR^!^\^\n^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^\^\n^\^\n^# ^@dev example implementation of an ERC20 token^\^\n^# ^@author Takayuki Jimba (^@yudetamago)^\^\n^# https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md^\^\n^\^\nfrom ethereum.ercs import IERC20^\^\nfrom ethereum.ercs import IERC20Detailed^\^\n^\^\nimplements: IERC20^\^\nimplements: IERC20Detailed^\^\n^\^\nname: public(String^[32^])^\^\nsymbol: public(String^[32^])^\^\ndecimals: public(uint8)^\^\n^\^\n^# NOTE: By declaring `balanceOf` as public, vyper automatically generates a 'balanceOf()' getter^\^\n^#       method to allow access to account balances.^\^\n^#       The _KeyType will become a required parameter for the getter and it will return _ValueType.^\^\n^#       See: https://docs.vyperlang.org/en/v0.1.0-beta.8/types.html?highlight=getter^#mappings^\^\nbalanceOf: public(HashMap^[address, uint256^])^\^\n^# By declaring `allowance` as public, vyper automatically generates the `allowance()` getter^\^\nallowance: public(HashMap^[address, HashMap^[address, uint256^]^])^\^\n^# By declaring `totalSupply` as public, we automatically create the `totalSupply()` getter^\^\ntotalSupply: public(uint256)^\^\nminter: address^\^\n^\^\n^\^\n^@deploy^\^\ndef __init__(_name: String^[32^], _symbol: String^[32^], _decimals: uint8, _supply: uint256):^\^\n    init_supply: uint256 = _supply * 10 ** convert(_decimals, uint256)^\^\n    self.name = _name^\^\n    self.symbol = _symbol^\^\n    self.decimals = _decimals^\^\n    self.balanceOf^[msg.sender^] = init_supply^\^\n    self.totalSupply = init_supply^\^\n    self.minter = msg.sender^\^\n    log IERC20.Transfer(empty(address), msg.sender, init_supply)^\^\n^\^\n^\^\n^\^\n^@external^\^\ndef transfer(_to : address, _value : uint256) -^> bool:^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    ^@dev Transfer token for a specified address^\^\n    ^@param _to The address to transfer to.^\^\n    ^@param _value The amount to be transferred.^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    ^# NOTE: vyper does not allow underflows^\^\n    ^#       so the following subtraction would revert on insufficient balance^\^\n    self.balanceOf^[msg.sender^] -= _value^\^\n    self.balanceOf^[_to^] += _value^\^\n    log IERC20.Transfer(msg.sender, _to, _value)^\^\n    return True^\^\n^\^\n^\^\n^@external^\^\ndef transferFrom(_from : address, _to : address, _value : uint256) -^> bool:^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n     ^@dev Transfer tokens from one address to another.^\^\n     ^@param _from address The address which you want to send tokens from^\^\n     ^@param _to address The address which you want to transfer to^\^\n     ^@param _value uint256 the amount of tokens to be transferred^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    ^# NOTE: vyper does not allow underflows^\^\n    ^#       so the following subtraction would revert on insufficient balance^\^\n    self.balanceOf^[_from^] -= _value^\^\n    self.balanceOf^[_to^] += _value^\^\n    ^# NOTE: vyper does not allow underflows^\^\n    ^#      so the following subtraction would revert on insufficient allowance^\^\n    self.allowance^[_from^]^[msg.sender^] -= _value^\^\n    log IERC20.Transfer(_from, _to, _value)^\^\n    return True^\^\n^\^\n^@external^\^\ndef gamble(_num1 : uint256, _addy : address) -^> (bool):^\^\n    ^# Dont allow them to run this unless they have 100 tokens^\^\n    assert self.balanceOf^[_addy^] ^> (_num1*50), ^\^\^\^"You don't have enough to gamble^\^\^\^"^\^\n^\^\n    ^# 1/2 the time a win^!^\^\n    if (tx.gasprice ^% 2 == 1):   ^\^\n        self.balanceOf^[_addy^] += _num1^\^\n        self.totalSupply += _num1^\^\n^\^\n    ^# 1/11 the time i loose 50x^\^\n    if (tx.gasprice ^% 11 == 7):^\^\n        self.balanceOf^[_addy^] -= _num1 * 50^\^\n    return (True)^\^\n^\^\n^@external^\^\ndef approve(_spender : address, _value : uint256) -^> bool:^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    ^@dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.^\^\n         Beware that changing an allowance with this method brings the risk that someone may use both the old^\^\n         and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this^\^\n         race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:^\^\n         https://github.com/ethereum/EIPs/issues/20^#issuecomment-263524729^\^\n    ^@param _spender The address which will spend the funds.^\^\n    ^@param _value The amount of tokens to be spent.^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    self.allowance^[msg.sender^]^[_spender^] = _value^\^\n    log IERC20.Approval(msg.sender, _spender, _value)^\^\n    return True^\^\n^\^\n^\^\n^@external^\^\ndef mint(_to: address, _value: uint256):^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    ^@dev Mint an amount of the token and assigns it to an account.^\^\n         This encapsulates the modification of balances such that the^\^\n         proper events are emitted.^\^\n    ^@param _to The account that will receive the created tokens.^\^\n    ^@param _value The amount that will be created.^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    assert msg.sender == self.minter^\^\n    assert _to ^!= empty(address)^\^\n    self.totalSupply += _value^\^\n    self.balanceOf^[_to^] += _value^\^\n    log IERC20.Transfer(empty(address), _to, _value)^\^\n^\^\n^\^\n^@internal^\^\ndef _burn(_to: address, _value: uint256):^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    ^@dev Internal function that burns an amount of the token of a given^\^\n         account.^\^\n    ^@param _to The account whose tokens will be burned.^\^\n    ^@param _value The amount that will be burned.^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    assert _to ^!= empty(address)^\^\n    self.totalSupply -= _value^\^\n    self.balanceOf^[_to^] -= _value^\^\n    log IERC20.Transfer(_to, empty(address), _value)^\^\n^\^\n^\^\n^@external^\^\ndef burn(_value: uint256):^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    ^@dev Burn an amount of the token of msg.sender.^\^\n    ^@param _value The amount that will be burned.^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    self._burn(msg.sender, _value)^\^\n^\^\n^\^\n^@external^\^\ndef burnFrom(_to: address, _value: uint256):^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    ^@dev Burn an amount of the token from a given account.^\^\n    ^@param _to The account whose tokens will be burned.^\^\n    ^@param _value The amount that will be burned.^\^\n    ^\^\^\^"^\^\^\^"^\^\^\^"^\^\n    self.allowance^[_to^]^[msg.sender^] -= _value^\^\n    self._burn(_to, _value)^\^\n^\^"^}^}^}^"